# EnigmaCTF - Gghibberish Writeup

**Challenge Name:** Gghibberish  
**Category:** Cryptography (Lattice)

## Challenge Description
We are given a file `chall.bin` which contains a basis matrix $B$ and a target vector $c$. The challenge hints at "lattice based cryptography" and implies we need to find a secret vector. The name "Gghibberish" likely refers to the GGH cryptosystem, which is based on the Closest Vector Problem (CVP).

## Solution Overview
This is a classic variation of the Closest Vector Problem (CVP).
- We have a lattice $L$ generated by the basis $B$.
- The ciphertext $c$ is a point close to a lattice point $v$, such that $c = v + e$ where $e$ is a small error vector.
- Our goal is to find the closest lattice point $v$, recovering the message which is encoded in the coefficients of $v$ with respect to the basis $B$.

While CVP is generally hard, for specific parameters and small errors, it can often be solved using the **Embedding Technique** to transform it into a Shortest Vector Problem (SVP), which can then be approximated using the **LLL (Lenstra–Lenstra–Lovász)** algorithm.

### The Embedding Technique
We construct a new lattice basis $M'$ by embedding the CVP instance into a higher dimension:
$$
M' = \begin{bmatrix}
B & 0 \\
c & 1
\end{bmatrix}
$$
Vectors in this new lattice are linear combinations of the rows. A specific combination will yield the vector $(c - v, 1) = (e, 1)$. Since the error $e$ is small, this vector (or its negation) will be one of the shortest vectors in the reduced basis.

## Implementation
We used SageMath to implement the attack.

1. **Parse Data**: Extract the matrix $B$ and vector $c$ from the input file.
2. **Construct Embedding**: Create the augmented matrix.
3. **LLL Reduction**: Reduce the basis.
4. **Extract Error**: Look for a row in the reduced basis ending in $\pm 1$. The first part of this row is our error vector candidate.
5. **Recover Message**: Calculate $v = c - e$ and solve the linear system $x \cdot B = v$ to find the integer coefficients $x$.
6. **Decode**: The coefficients correspond to ASCII values of a Base32 string.

### Solver Script (`solve.sage`)
```python
import ast
from sage.all import *

# ... (Read chall.bin to get B_list and c_list) ...

B = Matrix(ZZ, B_list)
c = vector(ZZ, c_list)
rows = B.nrows()
cols = B.ncols()

# Kannan's embedding
M = Matrix(ZZ, rows + 1, cols + 1)
M.set_block(0, 0, B)
M[rows, :cols] = c
M[rows, cols] = 1 

M_red = M.LLL()

diff_vec = None
for row in M_red:
    if row[cols] == 1:
        diff_vec = row[:cols]
        break
    elif row[cols] == -1:
        diff_vec = -row[:cols] # Adjust sign
        break

if diff_vec is not None:
    v = c - diff_vec
    coeffs = B.solve_left(v)
    
    flag = ""
    for x in coeffs:
        try:
            flag += chr(int(x))
        except:
            flag += "?"
    print(f"Recovered string: {flag}")
```

## Result
The recovered Base32 string was:
`MVXGSZ3NMFBVIRRSGZ5XK4ZTL5RDG5DUMVZF6ZLOMNZHS4DUNEYG4X3TMNUDG3LFONPWSMJYNMZGU7I=`

Decoding this gives the flag:

**Flag:** `enigmaCTF26{us3_b3tter_encrypti0n_sch3mes_i18k2j}`

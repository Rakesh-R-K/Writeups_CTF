import ast
from sage.all import *

def solve():
    print("Reading chall.bin...")
    with open("chall.bin", "r") as f:
        lines = f.readlines()

    matrix_lines = []
    reading_matrix = False
    c_line = ""
    for line in lines:
        line = line.strip()
        if line == "B:":
            reading_matrix = True
            continue
        if line.startswith("sigma"):
            reading_matrix = False
            continue
        if line.startswith("c ="):
            c_line = line.split("=")[1].strip()
            continue
        
        if reading_matrix and line:
            # Join split lines if necessary, but here each line seems to be a full row
            matrix_lines.append(line)

    print("Parsing data...")
    B_list = [ast.literal_eval(l) for l in matrix_lines]
    c_list = ast.literal_eval(c_line)

    B = Matrix(ZZ, B_list)
    c = vector(ZZ, c_list)
    
    rows = B.nrows()
    cols = B.ncols()
    print(f"B dimensions: {rows} x {cols}")
    print(f"c dimension: {len(c_list)}")

    # Embedding CVP -> SVP
    # Construct matrix [ B  0 ]
    #                  [ c  1 ]
    # This is slightly wrong, usually we want v close to c => v - c is small.
    # The lattice L is generated by rows of B.
    # We want sum(a_i * b_i) approx c.
    # sum(a_i * b_i) - c = small error
    
    # Kannan's embedding:
    # Lattice L' basis:
    # [ b_1   0 ]
    # [ ...   0 ]
    # [ b_n   0 ]
    # [  c    1 ]
    
    # If we reduce this basis, we might find a vector (u, 1) or (u, -1) where u = v - c is small.
    # Let's try this.
    
    print("Constructing embedding matrix...")
    M = Matrix(ZZ, rows + 1, cols + 1)
    M.set_block(0, 0, B)
    M[rows, :cols] = c
    M[rows, cols] = 1 # Weight. If sigma=1, error is small. 1 might be okay. Maybe larger?
    
    print("Running LLL...")
    M_red = M.LLL()
    
    diff_vec = None
    
    for i in range(M_red.nrows()):
        row = M_red[i]
        if row[cols] == 1:
            diff_vec = row[:cols]
            print(f"Found row with 1 at end: index {i}")
            break
        elif row[cols] == -1:
            diff_vec = -row[:cols]
            print(f"Found row with -1 at end: index {i}")
            break

    if diff_vec is not None:
        # diff_vec = c - v  => v = c - diff_vec
        # Wait, in the embedding [c 1], a vector in lattice is linear combo.
        # k * (c, 1) + sum(x_i * (b_i, 0)) = (k*c + v, k)
        # If we get last coord 1, then k=1.
        # Res = c + v_lattice.
        # We want c - v_lattice = small.
        # So we want (c - v, 1) to be short.
        # So diff_vec corresponds to c - v (approx error).
        # v = c - diff_vec
        
        v = c - diff_vec
        print("Recovered vector v. Checking if it is in lattice...")
        
        try:
            coeffs = B.solve_left(v)
            print("Message coefficients recovered!")
            
            # Try to decode to string
            # Coefficients are likely the characters
            flag = ""
            for x in coeffs:
                x_int = int(x)
                if 0 <= x_int < 256:
                    flag += chr(x_int)
                else:
                    flag += "?"
            print(f"Possible flag: {flag}")
            
            # Alternative: maybe diff_vec is v - c? Then v = c + diff_vec
            v2 = c + diff_vec
            try:
                coeffs2 = B.solve_left(v2)
                flag2 = ""
                for x in coeffs2:
                    if 0 <= int(x) < 256:
                        flag2 += chr(int(x))
                print(f"Alternative flag: {flag2}")
            except:
                pass
                
        except ValueError:
            print("Recovered vector v is NOT in the lattice.")
            
    else:
        print("Could not find row with +/- 1 in the last column.")
        # Check smallest vectors anyway
        print("Checking first few rows of reduced basis")
        for i in range(min(5, M_red.nrows())):
            print(f"Row {i}: {M_red[i]}")

if __name__ == "__main__":
    solve()
